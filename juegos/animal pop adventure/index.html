<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AzDi Animal Pop | Candy Crush Style</title>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --map-bg-sky: #87ceeb;
            --map-bg-grass: #a0d85a;
            --level-node-color: #f7a52e; /* Naranja caramelo */
            --level-locked-color: #8c8c8c;
            --game-bg-sky: #6ddaff;
            --game-bg-grass: #88c049;
            --panel-color: #ff99cc; /* Rosa chicle */
            --text-color: #fff;
            --font-main: 'Luckiest Guy', cursive;
            --font-secondary: 'Roboto', sans-serif;
            --candy-red: #ff4d4d;
            --candy-blue: #4d4dff;
            --candy-green: #4dff4d;
            --candy-yellow: #ffff4d;
            --candy-purple: #ff4dff;
            --candy-orange: #ff994d;
        }

        body {
            margin: 0;
            font-family: var(--font-secondary);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #222; /* Fondo general gris oscuro */
        }

        /* --- CONTENEDOR PRINCIPAL DEL JUEGO --- */
        #game-wrapper {
            width: 450px; /* Ancho fijo para el juego, como Candy Crush */
            height: 750px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #7bb0e3 0%, #3a75c1 100%); /* Fondo azul degradado */
            position: relative;
            overflow: hidden;
            border-radius: 10px;
        }

        /* --- MAPA DE NIVELES (Pantalla 1) --- */
        #map-screen {
            display: block; /* Por defecto visible */
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, var(--map-bg-sky) 0%, var(--map-bg-grass) 100%);
            position: absolute;
            top: 0; left: 0;
            padding-top: 50px; /* Espacio para el top bar */
            overflow-y: scroll; /* Scroll para los niveles */
            -webkit-overflow-scrolling: touch;
        }

        .map-path {
            position: absolute;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='20' viewBox='0 0 100 20'%3E%3Cpath d='M0 10 Q 25 0, 50 10 T 100 10' stroke='%23ffed8a' stroke-width='4' fill='none' /%3E%3C/svg%3E");
            background-repeat: repeat-x;
            height: 20px;
            width: 100%;
            z-index: 1;
        }
        
        .map-nodes {
            position: relative;
            width: 80%;
            margin: 0 auto;
            padding-top: 50px; /* Empieza m谩s abajo en el mapa */
        }

        .level-node {
            position: absolute;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background-color: var(--level-node-color);
            border: 4px solid var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-main);
            font-size: 24px;
            color: var(--text-color);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s, background-color 0.2s;
            z-index: 2;
        }

        .level-node:hover:not(.locked) {
            transform: scale(1.1);
            background-color: #ffc107;
        }

        .level-node.locked {
            background-color: var(--level-locked-color);
            border-color: #555;
            cursor: not-allowed;
            filter: grayscale(80%);
        }

        /* --- TOP BAR DEL MAPA --- */
        #map-topbar {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 50px;
            background: linear-gradient(to bottom, #5d8ecf 0%, #3a75c1 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-family: var(--font-main);
            font-size: 20px;
            justify-content: space-between;
            color: var(--text-color);
            z-index: 10;
            border-bottom: 2px solid rgba(0,0,0,0.1);
        }

        /* --- PANTALLA DE JUEGO (Pantalla 2) --- */
        #game-screen {
            display: none; /* Por defecto oculto */
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, var(--game-bg-sky) 0%, var(--game-bg-grass) 100%);
            position: absolute;
            top: 0; left: 0;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .game-top-panel {
            width: 100%;
            height: 60px;
            background-color: var(--panel-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-sizing: border-box;
            border-bottom: 3px solid rgba(0,0,0,0.2);
            font-family: var(--font-main);
            font-size: 18px;
            color: var(--text-color);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .game-top-panel div span {
            font-size: 22px;
            margin-left: 5px;
        }

        #grid-container {
            position: relative;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 10px;
            margin: 20px 0;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            width: 90%; /* Ajustar ancho para dejar espacio */
            height: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* 8 columnas flexibles */
            grid-template-rows: repeat(8, 1fr);   /* 8 filas flexibles */
            gap: 5px;
            aspect-ratio: 1 / 1; /* Asegura que sea cuadrado */
            max-width: 400px; /* Limite de tama帽o */
        }

        .cell {
            background-color: rgba(255,255,255,0.1); /* Fondo transl煤cido */
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px; /* Tama帽o de los animales */
            cursor: pointer;
            transition: transform 0.1s ease-out, opacity 0.1s ease-out, background-color 0.2s ease-out;
            user-select: none;
            position: relative; /* Para animaciones */
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        .cell.selected {
            transform: scale(1.08);
            outline: 3px solid #ffff00; /* Borde amarillo para seleccionado */
            box-shadow: 0 0 15px #ffff00;
        }

        .game-bottom-panel {
            width: 100%;
            height: 80px;
            background-color: var(--panel-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-sizing: border-box;
            border-top: 3px solid rgba(0,0,0,0.2);
            font-family: var(--font-main);
            font-size: 20px;
            color: var(--text-color);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .game-button {
            background: linear-gradient(45deg, #ff4d4d, #ff99cc);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 18px;
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        .game-button:hover {
            transform: translateY(-2px);
        }

        /* --- ANIMACIONES --- */
        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        .cell.popping { animation: pop 0.3s forwards ease-out; }
        .cell.falling { transition: transform 0.3s ease-out; }

        @keyframes hintPulse {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.4); }
    100% { transform: scale(1); filter: brightness(1); }
}

.hint-animation {
    animation: hintPulse 1s infinite ease-in-out;
    z-index: 20;
    box-shadow: 0 0 15px gold !important;
    background: rgba(255, 255, 255, 0.5) !important;
}
    </style>
</head>

<body>

    <div id="game-wrapper">

        <div id="map-screen">
            <div id="map-topbar">
                <span>AzDi Animal Pop!</span>
                <span id="map-level-display">Lvl 1</span>
            </div>
            <div class="map-nodes">
                </div>
        </div>

        <div id="game-screen">
            <div class="game-top-panel">
                <div>NIVEL:<span id="level-display">1</span></div>
                <div>META:<span id="target-display">1000</span></div>
            </div>

            <div id="grid-container">
                </div>

            <div class="game-bottom-panel">
                <div>MOVIMIENTOS:<span id="moves-display">50</span></div>
                <div>PUNTOS:<span id="score-display">0</span></div>
            </div>
            <button class="game-button" onclick="goToMap()">SALIR DEL NIVEL</button>
        </div>

    </div>

<script>
    const animals = ["", "", "", "", "", "", "", ""]; // Tus animales
    const SIZE = 8; // Grid de 8x8

    let currentLevel = 1;
    let currentScore = 0;
    let targetScore = 0;
    let movesLeft = 0;
    let unlockedLevels = parseInt(localStorage.getItem("animalpop_unlocked") || 1);

    let gameGrid = [];
    let selectedCell = null;
    let isGameAnimating = false; // Bloquea clics durante animaciones

    const mapScreen = document.getElementById("map-screen");
    const gameScreen = document.getElementById("game-screen");
    const gridContainer = document.getElementById("grid-container");

    const levelDisplay = document.getElementById("level-display");
    const targetDisplay = document.getElementById("target-display");
    const movesDisplay = document.getElementById("moves-display");
    const scoreDisplay = document.getElementById("score-display");
    const mapLevelDisplay = document.getElementById("map-level-display");


    /* --- MAPA DE NIVELES --- */
    function initMap() {
        mapScreen.style.display = "block";
        gameScreen.style.display = "none";
        document.querySelector('.map-nodes').innerHTML = '';
        mapLevelDisplay.textContent = `Lvl ${unlockedLevels}`;

        const levelPositions = [ // Coordenadas para que los niveles se vean como un camino
            { x: 30, y: 50 }, { x: 100, y: 20 }, { x: 200, y: 70 }, { x: 300, y: 40 },
            { x: 350, y: 120 }, { x: 280, y: 180 }, { x: 180, y: 150 }, { x: 80, y: 220 },
            { x: 150, y: 300 }, { x: 250, y: 280 }, { x: 320, y: 350 }, { x: 250, y: 420 },
            { x: 150, y: 450 }, { x: 80, y: 530 }, { x: 180, y: 580 }, { x: 280, y: 620 },
            { x: 350, y: 550 }, { x: 300, y: 480 }, { x: 200, y: 500 }, { x: 100, y: 400 }
        ];

        for (let i = 1; i <= 20; i++) {
            const node = document.createElement("div");
            node.className = "level-node " + (i > unlockedLevels ? "locked" : "");
            node.textContent = i;
            
            const pos = levelPositions[i - 1];
            if (pos) { // Asegurarse de que hay una posici贸n definida
                node.style.left = `${pos.x}px`;
                node.style.top = `${pos.y + (i * 30)}px`; // Ajuste para que se vea bien con scroll
            }

            node.onclick = () => {
                if (i <= unlockedLevels && !isGameAnimating) {
                    startLevel(i);
                }
            };
            document.querySelector('.map-nodes').appendChild(node);
            
            // A帽adir el camino (simple, se puede mejorar con SVG din谩mico)
            if (i < 20 && pos && levelPositions[i]) {
                const pathEl = document.createElement("div");
                pathEl.className = "map-path";
                // Posici贸n entre nodos (aproximada)
                pathEl.style.left = `${pos.x}px`;
                pathEl.style.top = `${pos.y + (i * 30) + 30}px`;
                pathEl.style.width = `${Math.abs(levelPositions[i].x - pos.x) + 100}px`;
                document.querySelector('.map-nodes').appendChild(pathEl);
            }
        }
    }


    /* --- INICIAR NIVEL --- */
    function startLevel(lvl) {
        currentLevel = lvl;
        currentScore = 0;
        targetScore = lvl * 1000; // La meta aumenta por nivel
        movesLeft = 50 - (lvl * 2); // Menos movimientos en niveles avanzados
        if (movesLeft < 10) movesLeft = 10; // M铆nimo de 10 movimientos
        resetHintTimer();
        levelDisplay.textContent = currentLevel;
        scoreDisplay.textContent = currentScore;
        targetDisplay.textContent = targetScore;
        movesDisplay.textContent = movesLeft;

        mapScreen.style.display = "none";
        gameScreen.style.display = "flex";

        generateCleanGrid();
        renderGrid();
    }

    /* Genera una cuadr铆cula sin combinaciones iniciales */
    function generateCleanGrid() {
        gameGrid = [];
        for (let r = 0; r < SIZE; r++) {
            gameGrid[r] = [];
            for (let c = 0; c < SIZE; c++) {
                let val;
                do {
                    val = randomAnimal();
                    gameGrid[r][c] = val;
                } while (checkInitialMatch(r, c, val));
            }
        }
    }

    /* Comprueba si al colocar un animal se forma un match de 3 */
    function checkInitialMatch(r, c, val) {
        if (c > 1 && gameGrid[r][c - 1] === val && gameGrid[r][c - 2] === val) return true;
        if (r > 1 && gameGrid[r - 1][c] === val && gameGrid[r - 2][c] === val) return true;
        return false;
    }

    /* Devuelve un animal aleatorio */
    function randomAnimal() {
        return animals[Math.floor(Math.random() * animals.length)];
    }

    /* --- RENDERIZADO DEL TABLERO --- */
    function renderGrid() {
        gridContainer.innerHTML = '';
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const cellDiv = document.createElement("div");
                cellDiv.className = "cell";
                cellDiv.id = `cell-${r}-${c}`;
                cellDiv.textContent = gameGrid[r][c] || "";
                cellDiv.onclick = () => clickCell(r, c);
                gridContainer.appendChild(cellDiv);
            }
        }
    }
function findPossibleMatch() {
    // Escanea todo el tablero buscando un movimiento que genere match
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            // Probar hacia la derecha
            if (c < SIZE - 1) {
                swap(r, c, r, c + 1);
                if (findMatches().length > 0) {
                    swap(r, c, r, c + 1); // Deshacer
                    return { r1: r, c1: c, r2: r, c2: c + 1 };
                }
                swap(r, c, r, c + 1); // Deshacer
            }
            // Probar hacia abajo
            if (r < SIZE - 1) {
                swap(r, c, r + 1, c);
                if (findMatches().length > 0) {
                    swap(r, c, r + 1, c); // Deshacer
                    return { r1: r, c1: c, r2: r + 1, c2: c };
                }
                swap(r, c, r + 1, c); // Deshacer
            }
        }
    }
    return null;
}

let hintTimer;
function resetHintTimer() {
    clearTimeout(hintTimer);
    // Limpiamos rastros de pistas anteriores
    document.querySelectorAll('.cell').forEach(c => c.classList.remove('hint-animation'));
    // Si pasan 7 segundos sin tocar, aparece la pista
    hintTimer = setTimeout(() => {
        if (isProcessing) return;
        const move = findPossibleMatch();
        if (move) {
            document.getElementById(`cell-${move.r1}-${move.c1}`).classList.add('hint-animation');
            document.getElementById(`cell-${move.r2}-${move.c2}`).classList.add('hint-animation');
        }
    }, 7000); 
}
    /* --- GESTIN DE CLICS Y SWAPS --- */
    async function clickCell(r, c) resetHintTimer();{
        if (isGameAnimating) return; // Bloquear clics durante animaciones

        const clickedElement = document.getElementById(`cell-${r}-${c}`);

        if (!selectedCell) { // Primera selecci贸n
            selectedCell = { r, c, element: clickedElement };
            clickedElement.classList.add("selected");
        } else { // Segunda selecci贸n (intento de swap)
            const dist = Math.abs(selectedCell.r - r) + Math.abs(selectedCell.c - c);

            if (dist === 1) { // Son adyacentes, intentar swap
                isGameAnimating = true; // Bloquear clicks
                selectedCell.element.classList.remove("selected");

                // Animaci贸n visual del swap
                await animateSwap(selectedCell.r, selectedCell.c, r, c);
                swapGridValues(selectedCell.r, selectedCell.c, r, c);

                if (findMatches().length > 0) { // Hay matches, procesar
                    await handleMatches();
                } else { // No hay match, deshacer la animaci贸n y el swap
                    await animateSwap(r, c, selectedCell.r, selectedCell.c); // Deshacer visualmente
                    swapGridValues(selectedCell.r, selectedCell.c, r, c); // Deshacer en la grid
                }
                
                selectedCell = null;
                isGameAnimating = false; // Desbloquear clicks
                checkGameEnd();

            } else { // Segunda selecci贸n no adyacente, cambia la selecci贸n
                selectedCell.element.classList.remove("selected");
                selectedCell = { r, c, element: clickedElement };
                clickedElement.classList.add("selected");
            }
        }
    }

    /* Intercambia los valores en la cuadr铆cula */
    function swapGridValues(r1, c1, r2, c2) {
        let temp = gameGrid[r1][c1];
        gameGrid[r1][c1] = gameGrid[r2][c2];
        gameGrid[r2][c2] = temp;
    }

    /* Anima el intercambio de dos celdas */
    async function animateSwap(r1, c1, r2, c2) {
        const el1 = document.getElementById(`cell-${r1}-${c1}`);
        const el2 = document.getElementById(`cell-${r2}-${c2}`);

        // Calcula desplazamiento visual
        const rect1 = el1.getBoundingClientRect();
        const rect2 = el2.getBoundingClientRect();
        const dx = rect1.left - rect2.left;
        const dy = rect1.top - rect2.top;

        // Aplica transform para la animaci贸n
        el1.style.transition = `transform 0.2s ease-in-out`;
        el2.style.transition = `transform 0.2s ease-in-out`;
        el1.style.transform = `translate(${-dx}px, ${-dy}px)`;
        el2.style.transform = `translate(${dx}px, ${dy}px)`;

        await new Promise(resolve => setTimeout(resolve, 200)); // Espera la animaci贸n

        el1.style.transform = ''; // Quita transform para que vuelvan a su posici贸n CSS
        el2.style.transform = '';
        el1.style.transition = ''; // Limpia transiciones para evitar conflictos
        el2.style.transition = '';

        renderGrid(); // Vuelve a dibujar para que los elementos est茅n en sus nuevas posiciones
    }


    /* --- LGICA DE MATCHES Y CASCADA --- */
    function findMatches() {
        let matches = new Set(); // Usamos un Set para evitar duplicados

        // Horizontal
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE - 2; c++) {
                let val = gameGrid[r][c];
                if (val && val === gameGrid[r][c + 1] && val === gameGrid[r][c + 2]) {
                    matches.add(`${r}-${c}`);
                    matches.add(`${r}-${c + 1}`);
                    matches.add(`${r}-${c + 2}`);
                }
            }
        }
        // Vertical
        for (let c = 0; c < SIZE; c++) {
            for (let r = 0; r < SIZE - 2; r++) {
                let val = gameGrid[r][c];
                if (val && val === gameGrid[r + 1][c] && val === gameGrid[r + 2][c]) {
                    matches.add(`${r}-${c}`);
                    matches.add(`${r + 1}-${c}`);
                    matches.add(`${r + 2}-${c}`);
                }
            }
        }
        return Array.from(matches).map(s => { // Convierte el Set de nuevo en array de objetos
            const [r, c] = s.split('-').map(Number);
            return {r, c};
        });
    }

    async function handleMatches() {
        let matches = findMatches();
        if (matches.length === 0) {
            return;
        }

        // Animaci贸n de "pop" y puntuaci贸n
        matches.forEach(m => {
            const cellElement = document.getElementById(`cell-${m.r}-${m.c}`);
            if (cellElement) {
                cellElement.classList.add("popping");
            }
            gameGrid[m.r][m.c] = null; // Eliminar animal
            currentScore += 10;
        });
        scoreDisplay.textContent = currentScore; // Actualizar puntuaci贸n
        await new Promise(resolve => setTimeout(resolve, 300)); // Espera la animaci贸n de pop

        // Gravedad (ca铆da de animales)
        for (let c = 0; c < SIZE; c++) {
            let emptySpaces = 0;
            for (let r = SIZE - 1; r >= 0; r--) {
                if (gameGrid[r][c] === null) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    gameGrid[r + emptySpaces][c] = gameGrid[r][c];
                    gameGrid[r][c] = null;
                }
            }
            // Rellenar nuevos animales desde arriba
            for (let r = 0; r < emptySpaces; r++) {
                gameGrid[r][c] = randomAnimal();
            }
        }
        renderGrid(); // Vuelve a dibujar con los animales ca铆dos y nuevos

        await new Promise(resolve => setTimeout(resolve, 300)); // Espera la ca铆da

        // Recursividad: buscar m谩s matches despu茅s de la ca铆da
        if (findMatches().length > 0) {
            await handleMatches(); // Si hay m谩s matches, sigue procesando
        }
    }

    /* --- FIN DEL JUEGO --- */
    function checkGameEnd() {
        movesLeft--;
        movesDisplay.textContent = movesLeft;

        if (currentScore >= targetScore) {
            alert(`隆Nivel ${currentLevel} Superado!`);
            if (currentLevel === unlockedLevels && unlockedLevels < 20) {
                unlockedLevels++;
                localStorage.setItem("animalpop_unlocked", unlockedLevels);
            }
            goToMap();
        } else if (movesLeft <= 0) {
            alert(`隆GAME OVER! No quedan movimientos. Puntuaci贸n: ${currentScore}`);
            goToMap();
        }
    }

    function goToMap() {
        selectedCell = null;
        isGameAnimating = false;
        initMap();
    }

    /* --- INICIO DEL JUEGO AL CARGAR LA PGINA --- */
    initMap();
</script>

</body>
</html>
