<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>AzDi Merge | Edici贸n Completa</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #05070d;
            font-family: 'Orbitron', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Estrellas de fondo */
        #stars {
            position: fixed;
            inset: 0;
            z-index: -1;
        }

        /* HUD */
        #ui {
            text-align: center;
            padding: 20px;
            z-index: 5;
        }

        #score {
            font-size: 32px;
            color: #00f0ff;
            text-shadow: 0 0 15px #00f0ff;
            margin: 0;
        }

        #next-preview {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* Contenedor del Tablero */
        #game-container {
            position: relative;
            border: 4px solid #00f0ff;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.2);
            background: rgba(10, 15, 25, 0.8);
            overflow: hidden;
            cursor: crosshair;
        }

        canvas#board {
            display: block;
        }

        /* L铆nea de Danger */
        .danger-line {
            position: absolute;
            top: 80px;
            width: 100%;
            border-top: 2px dashed rgba(255, 0, 0, 0.4);
            pointer-events: none;
        }

        /* Men煤 de Game Over */
        #game-over {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card {
            background: #111827;
            padding: 40px;
            border-radius: 24px;
            border: 2px solid #ff00d4;
            text-align: center;
            box-shadow: 0 0 40px #ff00d444;
        }

        button {
            background: linear-gradient(90deg, #00f0ff, #ff00d4);
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-family: 'Orbitron';
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <canvas id="stars"></canvas>

    <div id="ui">
        <p id="score">PUNTOS: 0</p>
        <div id="next-preview">SIGUIENTE: <span id="next-emoji"></span></div>
    </div>

    <div id="game-container">
        <div class="danger-line"></div>
        <canvas id="board"></canvas>
    </div>

    <div id="game-over">
        <div class="card">
            <h2 style="color: #ff00d4">GAME OVER</h2>
            <p id="final-score">Puntos: 0</p>
            <button onclick="location.reload()">REINTENTAR</button>
        </div>
    </div>

<script>
    /* --- CONFIGURACIN --- */
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const starCanvas = document.getElementById("stars");
    const sctx = starCanvas.getContext("2d");

    canvas.width = 400;
    canvas.height = 600;
    starCanvas.width = window.innerWidth;
    starCanvas.height = window.innerHeight;

    const animals = ["","","","","","","","","",""];
    const colors = ["#ffffff","#ffff00","#ffcc00","#ff9900","#ff6600","#ff3300","#cc0099","#9933ff","#3366ff","#00f0ff"];
    const sizes = [20, 26, 32, 38, 45, 52, 60, 72, 85, 105];

    let entities = [];
    let score = 0;
    let nextType = 0;
    let isGameOver = false;

    /* --- ESTRELLAS --- */
    let stars = [];
    for(let i=0; i<150; i++) {
        stars.push({
            x: Math.random() * starCanvas.width,
            y: Math.random() * starCanvas.height,
            r: Math.random() * 2,
            opacity: Math.random()
        });
    }

    function drawStars() {
        sctx.clearRect(0, 0, starCanvas.width, starCanvas.height);
        sctx.fillStyle = "white";
        stars.forEach(s => {
            sctx.globalAlpha = s.opacity;
            sctx.beginPath();
            sctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            sctx.fill();
        });
        requestAnimationFrame(drawStars);
    }

    /* --- CLASE ENTIDAD (ANIMAL) --- */
    class Entity {
        constructor(x, y, type, isNew = false) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.radius = sizes[type];
            this.vx = 0;
            this.vy = 0;
            this.friction = 0.98;
            this.gravity = 0.6;
            this.bounce = 0.2;
            this.isStatic = false;
            this.isNew = isNew; // Para efectos visuales
        }

        update() {
            if (isGameOver) return;

            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;

            // Colisi贸n Suelo
            if (this.y + this.radius > canvas.height) {
                this.y = canvas.height - this.radius;
                this.vy *= -this.bounce;
                this.vx *= this.friction;
                this.isStatic = true;
            }

            // Colisi贸n Paredes
            if (this.x - this.radius < 0) {
                this.x = this.radius;
                this.vx *= -0.5;
            } else if (this.x + this.radius > canvas.width) {
                this.x = canvas.width - this.radius;
                this.vx *= -0.5;
            }

            // Interacci贸n con otros
            for (let other of entities) {
                if (other === this) continue;

                let dx = this.x - other.x;
                let dy = this.y - other.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let minDist = this.radius + other.radius;

                if (distance < minDist) {
                    // SI SON IGUALES -> FUSIONAR
                    if (this.type === other.type) {
                        this.merge(other);
                        return;
                    }

                    // RESOLVER COLISIN (F铆sica de c铆rculos)
                    let angle = Math.atan2(dy, dx);
                    let overlap = minDist - distance;
                    
                    this.x += Math.cos(angle) * overlap * 0.5;
                    this.y += Math.sin(angle) * overlap * 0.5;
                    
                    this.vx += Math.cos(angle) * 0.5;
                    this.vy += Math.sin(angle) * 0.5;
                    this.isStatic = true;
                }
            }
        }

        merge(other) {
            if (this.type < animals.length - 1) {
                let nextLevel = this.type + 1;
                let newX = (this.x + other.x) / 2;
                let newY = (this.y + other.y) / 2;

                // Eliminar los dos actuales
                entities = entities.filter(e => e !== this && e !== other);

                // Crear el evolucionado
                let upgraded = new Entity(newX, newY, nextLevel, true);
                entities.push(upgraded);

                score += nextLevel * 25;
                document.getElementById("score").innerText = "PUNTOS: " + score;
            }
        }

        draw() {
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = colors[this.type];
            ctx.fillStyle = colors[this.type];
            
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.font = `${this.radius * 1.2}px serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(animals[this.type], this.x, this.y + 2);
            ctx.restore();
        }
    }

    /* --- BUCLE PRINCIPAL --- */
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        entities.forEach(e => {
            e.update();
            e.draw();
        });

        // Verificar derrota
        entities.forEach(e => {
            if (e.isStatic && e.y < 90 && !isGameOver) {
                gameOver();
            }
        });

        if (!isGameOver) requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        isGameOver = true;
        document.getElementById("game-over").style.display = "flex";
        document.getElementById("final-score").innerText = "Puntuaci贸n final: " + score;
    }

    /* --- CONTROLES --- */
    canvas.addEventListener("click", (e) => {
        if (isGameOver) return;

        let rect = canvas.getBoundingClientRect();
        let clickX = e.clientX - rect.left;
        
        // Limitar bordes
        let x = Math.max(30, Math.min(canvas.width - 30, clickX));
        
        // Crear pieza
        entities.push(new Entity(x, 40, nextType));

        // Preparar siguiente
        nextType = Math.random() < 0.3 ? 1 : 0;
        document.getElementById("next-emoji").innerText = animals[nextType];
    });

    // Iniciar
    drawStars();
    gameLoop();

</script>
</body>
</html>
